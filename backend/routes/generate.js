import { generateWorkflowFromText } from '../services/llm.js';
import { commitWorkflow, pushBranch } from '../services/git-helper.js';
import fs from 'fs/promises';
import path from 'path';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * POST /api/generate
 * Generate a workflow from natural language input
 */
export async function generateWorkflow(req, res) {
  try {
    const { text, demoMode } = req.body;

    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Please provide a text description'
      });
    }

    const mode = demoMode ? 'üé≠ DEMO MODE' : 'ü§ñ AI MODE';
    console.log(`\n${mode} - Generating workflow from: "${text}"\n`);

    // Timeline tracking
    const timeline = [];
    const startTime = Date.now();

    // Step 1: Generate workflow structure using LLM
    timeline.push({
      id: '1',
      timestamp: new Date().toISOString(),
      type: 'prompt',
      title: 'Parsed intent from natural language',
      details: `Analyzing: "${text}"`,
      status: 'pending'
    });

    const workflowData = await generateWorkflowFromText(text, demoMode);
    console.log(`‚úì Generated workflow: ${workflowData.workflowName}`);
    
    timeline[0].status = 'success';
    timeline[0].details = `Generated workflow: ${workflowData.workflowName}`;

    // Step 2: Create workflow directory
    const workflowId = workflowData.workflowName;
    const workflowDir = path.join(__dirname, '../../workflows', workflowId);
    const scriptsDir = path.join(workflowDir, 'scripts');
    const outputDir = path.join(workflowDir, 'output');
    const runsDir = path.join(workflowDir, 'runs');

    await fs.mkdir(scriptsDir, { recursive: true });
    await fs.mkdir(outputDir, { recursive: true });
    await fs.mkdir(runsDir, { recursive: true });
    console.log(`‚úì Created directories for ${workflowId}`);
    
    timeline.push({
      id: '2',
      timestamp: new Date().toISOString(),
      type: 'files',
      title: 'Files created',
      details: `Generated ${workflowData.tasks.length} tasks with scripts`,
      status: 'pending',
      metadata: {
        filesCreated: []
      }
    });

    // Step 3: Create Kestra YAML workflow file
    const kestraWorkflow = {
      id: workflowId,
      namespace: 'autotaskops',
      description: workflowData.description,
      tasks: workflowData.tasks.map(task => ({
        id: task.id,
        type: 'io.kestra.core.tasks.scripts.Bash',
        commands: [
          task.type === 'python' ? `python scripts/${task.scriptName}` : `bash scripts/${task.scriptName}`
        ]
      }))
    };

    if (workflowData.schedule) {
      kestraWorkflow.triggers = [{
        id: 'schedule',
        type: 'io.kestra.core.models.triggers.types.Schedule',
        cron: workflowData.schedule
      }];
    }

    const yamlContent = yaml.dump(kestraWorkflow, { indent: 2 });
    const yamlPath = path.join(workflowDir, `${workflowId}.yaml`);
    await fs.writeFile(yamlPath, yamlContent);
    console.log(`‚úì Created workflow YAML: ${workflowId}.yaml`);

    // Step 4: Write script files
    const createdFiles = [`${workflowId}/${workflowId}.yaml`];
    
    for (const [scriptName, scriptContent] of Object.entries(workflowData.scripts)) {
      const scriptPath = path.join(scriptsDir, scriptName);
      await fs.writeFile(scriptPath, scriptContent);
      
      // Make scripts executable on Unix systems
      if (process.platform !== 'win32') {
        await fs.chmod(scriptPath, 0o755);
      }
      
      createdFiles.push(`${workflowId}/scripts/${scriptName}`);
      console.log(`‚úì Created script: ${scriptName}`);
    }

    // Step 5: Create README for the workflow
    const readmeContent = `# ${workflowData.workflowName}

${workflowData.description}

## Generated From
\`\`\`
${text}
\`\`\`

## Tasks
${workflowData.tasks.map(t => `- **${t.name}**: ${t.description}`).join('\n')}

## Schedule
${workflowData.schedule ? `Runs on schedule: \`${workflowData.schedule}\`` : 'Manual execution only'}

## Running This Workflow

### Using the Backend API
\`\`\`bash
curl -X POST http://localhost:3001/api/run \\
  -H "Content-Type: application/json" \\
  -d '{"workflowId": "${workflowId}"}'
\`\`\`

### Using the CLI Runner
\`\`\`bash
cd backend
node runner.js --workflow ../workflows/${workflowId}/${workflowId}.yaml
\`\`\`

### Using Kestra
\`\`\`bash
# If Kestra is running
cd kestra
# Import workflow and execute via Kestra UI
\`\`\`

## Output
Results will be saved to \`output/\` directory.
Execution logs are stored in \`runs/\` directory.

## Scripts
${Object.keys(workflowData.scripts).map(s => `- \`scripts/${s}\``).join('\n')}

---
*Generated by AutoTaskOps*
`;

    await fs.writeFile(path.join(workflowDir, 'README.md'), readmeContent);
    createdFiles.push(`${workflowId}/README.md`);
    
    timeline[1].status = 'success';
    timeline[1].metadata.filesCreated = createdFiles;

    // Step 6: Commit to git (optional, non-blocking)
    let gitInfo = null;
    timeline.push({
      id: '3',
      timestamp: new Date().toISOString(),
      type: 'commit',
      title: 'Git commit & branch creation',
      status: 'pending'
    });
    try {
      gitInfo = await commitWorkflow(workflowId, createdFiles);
      
      if (gitInfo && gitInfo.branch && !gitInfo.skipped) {
        console.log(`‚úì Committed to branch: ${gitInfo.branch}`);
        timeline[2].status = 'success';
        timeline[2].details = `Committed to ${gitInfo.branch}`;
        timeline[2].metadata = {
          commitHash: gitInfo.commit,
          branch: gitInfo.branch
        };
        
        // Try to push (non-blocking)
        const pushResult = await pushBranch(gitInfo.branch);
        if (pushResult.pushed) {
          console.log(`‚úì Pushed to remote`);
          gitInfo.pushed = true;
        }
      } else {
        timeline[2].status = 'error';
        timeline[2].details = 'Git operations skipped';
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è  Git operations skipped: ${error.message}`);
      timeline[2].status = 'error';
      timeline[2].details = error.message;
    }

    // Return success response with timeline
    const duration = Date.now() - startTime;
    res.json({
      success: true,
      workflow: {
        id: workflowId,
        name: workflowData.workflowName,
        description: workflowData.description,
        path: `/workflows/${workflowId}`,
        yamlFile: `${workflowId}.yaml`,
        tasks: workflowData.tasks.length,
        schedule: workflowData.schedule,
        scripts: Object.keys(workflowData.scripts)
      },
      git: gitInfo,
      timeline: timeline,
      duration: duration,
      message: 'Workflow generated successfully'
    });

  } catch (error) {
    console.error('Error generating workflow:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}

export default generateWorkflow;
