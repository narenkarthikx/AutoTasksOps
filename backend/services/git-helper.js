import { simpleGit } from 'simple-git';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize git with the workflows directory as base
const workflowsDir = path.join(__dirname, '../../workflows');
const git = simpleGit(workflowsDir);

/**
 * Create a new branch and commit workflow files
 * @param {string} workflowId - Unique workflow identifier
 * @param {Array<string>} files - List of files to commit (relative to workflows dir)
 * @returns {Promise<Object>} Branch info and commit hash
 */
export async function commitWorkflow(workflowId, files) {
  // GIT OPERATIONS DISABLED FOR SIMPLICITY
  // Workflows are just saved as files - no git commits, no branches
  console.log(`✓ Workflow files created (git operations disabled)`);
  return { 
    branch: null, 
    commit: null, 
    skipped: true,
    reason: 'Git operations disabled for simplicity'
  };
  
  /* ORIGINAL CODE - DISABLED
  try {
    // Check if we're in a git repository
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
      console.log('Not a git repository, skipping git operations');
      return { branch: null, commit: null, skipped: true };
    }

    // Get current branch
    const status = await git.status();
    const currentBranch = status.current;

    // Stage files directly on current branch (no branching)
    const filePaths = files.map(f => path.join(workflowsDir, f));
    await git.add(filePaths);
    console.log(`✓ Staged ${files.length} file(s) on ${currentBranch}`);

    // Commit directly to current branch
    const commitMessage = `Add workflow: ${workflowId}\n\nGenerated by AutoTaskOps`;
    const commit = await git.commit(commitMessage);
    console.log(`✓ Committed: ${commit.commit} to ${currentBranch}`);

    return {
      branch: currentBranch,
      commit: commit.commit,
      message: commitMessage,
      currentBranch
    };
  } catch (error) {
    console.error('Git operation error:', error);
    throw new Error(`Failed to commit workflow: ${error.message}`);
  }
  */
}

/**
 * Push branch to remote
 * @param {string} branchName - Branch to push
 * @returns {Promise<Object>} Push result
 */
export async function pushBranch(branchName) {
  // PUSH DISABLED - No git operations
  console.log(`✓ Push skipped (git operations disabled)`);
  return { pushed: false, skipped: true };
  
  /* ORIGINAL CODE - DISABLED
  try {
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
      return { pushed: false, skipped: true };
    }

    // Check if remote exists
    const remotes = await git.getRemotes(true);
    if (remotes.length === 0) {
      console.log('No remote configured, skipping push');
      return { pushed: false, skipped: true, reason: 'No remote configured' };
    }

    // Push current branch to origin
    await git.push('origin', branchName);
    console.log(`✓ Pushed ${branchName} to origin`);

    return {
      pushed: true,
      branch: branchName,
      remote: 'origin'
    };
  } catch (error) {
    console.error('Push error:', error);
    // Don't throw - push failure shouldn't break workflow creation
    return {
      pushed: false,
      error: error.message
    };
  }
  */
}

/**
 * Initialize git repository if needed
 * @param {string} directory - Directory to initialize
 */
export async function initializeRepo(directory) {
  try {
    const gitInstance = simpleGit(directory);
    const isRepo = await gitInstance.checkIsRepo();
    
    if (!isRepo) {
      await gitInstance.init();
      console.log(`✓ Initialized git repository in ${directory}`);
    }
    
    return true;
  } catch (error) {
    console.error('Git init error:', error);
    return false;
  }
}

export default {
  commitWorkflow,
  pushBranch,
  initializeRepo
};
